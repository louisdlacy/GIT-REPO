"use strict";
/**
 * WARNING: DO NOT EDIT THIS FILE OR REMOVE IT FROM YOUR SCRIPTS IF YOU
 * ARE USING THE PARTS-BASED ANIMATION SYSTEM.
 *
 * Docs: https://github.com/todd-roberts/HWPBA
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.PB_AnimatedComponent = exports.PartsBasedAnimationSystem = void 0;
const hz = __importStar(require("horizon/core"));
/** No-op: brings the system into the world’s scripts. */
class PartsBasedAnimationSystem extends hz.Component {
    start() { }
}
exports.PartsBasedAnimationSystem = PartsBasedAnimationSystem;
hz.Component.register(PartsBasedAnimationSystem);
// ---------------- Axis helpers (now identity; exporter is HW-native) ----------------
const quatToHW = (q) => new hz.Quaternion(q[0], q[1], q[2], q[3]);
const vec3ToHW = (v) => new hz.Vec3(v[0], v[1], v[2]);
const parentScaleComp = (entity) => {
    const p = entity.parent.get();
    if (!p)
        return 1;
    const sx = p.transform.localScale.get().x;
    return 1 / sx;
};
// ---------------- Animator ----------------
class Animator {
    constructor() {
        this._animationTime = 0;
        this._currentAnimation = null;
        this._currentSpeed = 1;
        this._loop = true;
        this._callbacks = undefined;
        this._triggeredCallbacks = new Set();
        this._pendingPlay = null;
        this.configure = (config) => {
            this._animations = config.animations;
            this._parts = config.parts;
            if (this._pendingPlay) {
                const p = this._pendingPlay;
                this._pendingPlay = null;
                this.play(p);
            }
        };
        this.isConfigured = () => {
            return Boolean(this._animations);
        };
        this.play = (params) => {
            if (!this._animations) {
                this._pendingPlay = params;
                return;
            }
            const animationName = params.animationName;
            const speed = params.speed === undefined ? 1 : params.speed;
            const loop = params.loop === undefined ? true : params.loop;
            const callbacks = params.callbacks;
            this._animationTime = 0;
            this._triggeredCallbacks.clear();
            this._currentSpeed = speed;
            this._currentAnimation = this._animations[animationName] || null;
            if (!this._currentAnimation) {
                console.warn("[HWPBA] animation not found:", animationName, "available:", Object.keys(this._animations));
            }
            this._loop = loop;
            this._callbacks = callbacks;
        };
        this.changeSpeed = (speed) => {
            if (this._currentAnimation)
                this._currentSpeed = speed;
        };
        this.stop = () => {
            this._animationTime = 0;
            this._triggeredCallbacks.clear();
            this._currentAnimation = null;
            this._callbacks = undefined;
            this._loop = true;
            this._currentSpeed = 1;
        };
        this.update = (deltaTime) => {
            if (!this._currentAnimation)
                return;
            const times = this._currentAnimation.times;
            const animationLength = times[times.length - 1];
            const previousTime = this._animationTime;
            let newTime = this._animationTime + deltaTime * this._currentSpeed;
            if (newTime >= animationLength) {
                if (this._loop) {
                    newTime = newTime % animationLength;
                    this._triggeredCallbacks.clear();
                }
                else {
                    newTime = animationLength;
                    this._animationTime = newTime;
                    this.applyFinalFrame();
                    const onEnd = this._callbacks ? this._callbacks.onEnd : undefined;
                    this.stop();
                    if (onEnd)
                        onEnd();
                    return;
                }
            }
            this._animationTime = newTime;
            this.checkAndTriggerCallbacks(previousTime, newTime);
            const frames = this.getInterpolationFrames(times);
            const frameA = frames[0];
            const frameB = frames[1];
            const t = this.getInterpolationAmount(times[frameA], times[frameB]);
            this.applyAnimation(frameA, frameB, t);
        };
        this.checkAndTriggerCallbacks = (prev, curr) => {
            if (!this._callbacks || !this._currentAnimation)
                return;
            const byFrame = this._callbacks.byFrame;
            if (!byFrame)
                return;
            for (const k in byFrame) {
                const frame = Number(k);
                const time = this._currentAnimation.times[frame];
                if (!this._triggeredCallbacks.has(frame) && time > prev && time <= curr) {
                    const fn = byFrame[frame];
                    if (fn)
                        fn();
                    this._triggeredCallbacks.add(frame);
                }
            }
        };
        this.applyFinalFrame = () => {
            const i = this._currentAnimation
                ? this._currentAnimation.times.length - 1
                : 0;
            this.applyAnimation(i, i, 0);
        };
        this.getInterpolationFrames = (times) => {
            if (this._animationTime < times[0])
                return [times.length - 1, 0];
            let l = 0;
            let r = times.length - 1;
            while (l <= r) {
                const m = (l + r) >> 1;
                if (times[m] <= this._animationTime)
                    l = m + 1;
                else
                    r = m - 1;
            }
            const a = r < 0 ? 0 : r;
            const b = a + 1 < times.length ? a + 1 : times.length - 1;
            return [a, b];
        };
        this.getInterpolationAmount = (a, b) => {
            const dt = b - a;
            return dt === 0 ? 0 : (this._animationTime - a) / dt;
        };
        this.applyAnimation = (frameA, frameB, t) => {
            for (let i = 0; i < this._parts.length; i++) {
                const part = this._parts[i];
                this.applyLocalPosition({
                    entity: part.entity,
                    nodeName: part.nodeName,
                    frameA,
                    frameB,
                    interpolationAmount: t,
                });
                this.applyLocalRotation({
                    entity: part.entity,
                    nodeName: part.nodeName,
                    frameA,
                    frameB,
                    interpolationAmount: t,
                });
            }
        };
        this.applyLocalPosition = ({ nodeName, frameA, frameB, interpolationAmount, entity, }) => {
            if (!this._currentAnimation)
                return;
            const partPositions = this._currentAnimation.positions[nodeName];
            if (!partPositions)
                return;
            const A = partPositions[frameA];
            const B = partPositions[frameB];
            if (!A || !B)
                return;
            const vA = vec3ToHW(A);
            const vB = vec3ToHW(B);
            let p = hz.Vec3.lerp(vA, vB, interpolationAmount);
            // compensate for *parent* scale
            const k = parentScaleComp(entity);
            if (k !== 1)
                p = p.mul(k);
            entity.transform.localPosition.set(p);
        };
        this.applyLocalRotation = ({ nodeName, frameA, frameB, interpolationAmount, entity, }) => {
            if (!this._currentAnimation)
                return;
            const partRotations = this._currentAnimation.rotations[nodeName];
            if (!partRotations)
                return;
            const QA = partRotations[frameA];
            const QB = partRotations[frameB];
            if (!QA || !QB)
                return;
            const qA = quatToHW(QA);
            const qB = quatToHW(QB);
            const q = hz.Quaternion.slerp(qA, qB, interpolationAmount);
            entity.transform.localRotation.set(q);
        };
    }
}
class PB_AnimatedComponent extends hz.Component {
    constructor() {
        super(...arguments);
        this._animator = new Animator();
        this._loaded = false;
        this.onPreStart = () => { };
        this.onUpdate = (_dt) => { };
        this.collectNodes = (root) => {
            const out = [];
            const stack = root.children.get().slice();
            while (stack.length) {
                const n = stack.pop();
                out.push(n);
                const kids = n.children.get();
                if (kids && kids.length) {
                    for (let i = 0; i < kids.length; i++)
                        stack.push(kids[i]);
                }
            }
            return out;
        };
        /** Strict: require prefix and strip it. No other normalization. */
        this.resolveNodeName = (raw, prefix, valid) => {
            if (!raw || !prefix)
                return null;
            if (raw.indexOf(prefix) !== 0)
                return null;
            const base = raw.slice(prefix.length);
            return valid.has(base) ? base : null;
        };
        this.applyInitialPlacement = (initialPositions, parts) => {
            for (let i = 0; i < parts.length; i++) {
                const entry = parts[i];
                const arr = initialPositions[entry.nodeName];
                if (!arr || arr.length < 3)
                    continue;
                // initialPositions are already Horizon-native; only compensate parent scale
                let v = vec3ToHW(arr);
                const k = parentScaleComp(entry.entity);
                if (k !== 1)
                    v = v.mul(k);
                entry.entity.transform.localPosition.set(v);
            }
        };
        this.loadAndBind = async () => {
            if (!this.props.animations) {
                throw new Error("Missing `animations` Text Asset on PB_AnimatedComponent.");
            }
            const asset = this.props.animations.as(hz.Asset);
            const data = await asset.fetchAsData();
            if (!data)
                throw new Error("Missing `animations` Text Asset on PB_AnimatedComponent.");
            let json = null;
            try {
                json = data.asJSON();
            }
            catch (e) {
                json = null;
            }
            if (!json)
                throw new Error("Failed to parse animation JSON. Ensure it matches the HWPBA format.");
            const validNames = new Set(Object.keys(json.initialPositions || {}));
            const prefix = json.namePrefix ? json.namePrefix : "";
            const parts = [];
            const nodes = this.collectNodes(this.entity);
            for (let i = 0; i < nodes.length; i++) {
                const e = nodes[i];
                const raw = e.name.get(); // use each child’s name
                const resolved = this.resolveNodeName(raw, prefix, validNames);
                if (resolved)
                    parts.push({ entity: e, nodeName: resolved });
            }
            this._animator.configure({ animations: json.animations, parts });
            this.applyInitialPlacement(json.initialPositions, parts);
        };
        this.update = ({ deltaTime }) => {
            if (!this._animator.isConfigured())
                return;
            if (!this._loaded) {
                if (this.props.visibleAfterLoad) {
                    this.entity.visible.set(true);
                }
                this._loaded = true;
            }
            this._animator.update(deltaTime);
            this.onUpdate(deltaTime);
        };
        this.playAnimation = (params) => {
            this._animator.play(params);
        };
        this.stopAnimation = () => {
            this._animator.stop();
        };
    }
    preStart() {
        this.entity.visible.set(false);
        this.connectLocalBroadcastEvent(hz.World.onUpdate, this.update);
        this.loadAndBind();
        this.onPreStart();
    }
}
exports.PB_AnimatedComponent = PB_AnimatedComponent;
PB_AnimatedComponent.propsDefinition = {
    animations: { type: hz.PropTypes.Asset },
    /** If true, the entity will be visible after the animations are loaded,
     * regardless of visibility configuration within the editor. */
    visibleAfterLoad: { type: hz.PropTypes.Boolean, default: true },
};
PB_AnimatedComponent.withProps = (extra) => ({ ...PB_AnimatedComponent.propsDefinition, ...extra });
